# -*- coding: utf-8 -*-
"""
Created on Wed Nov 18 09:31:35 2020

@author: Gabriela Linares y Ana Garzón
"""

def unidad(S):
  for x in S:
    if len(x) == 1:
      un = x[0]
      return un
  return None

def complemento(un):
  if un[0] == '-':
    return un[1]
  else:
    return '-' + un

def unit_propagate(S,I):

  y = True

  while y:

    for i in S:
      if len(i) == 0:
          return "Insatisfacible", {}

    un = unidad(S)

    if un != None:
      y = True
      #SE BORRAN LAS CLAUSULAS COMPLETAS QUE TIENEN A L
      if len(un) == 1:
        I[un] = 1
        
      else:
        I[complemento(un)] = 0
      S = [x for x in S if un not in x]
      #SE BORRA Lc DE LAS DEMÁS CLAUSULAS
      for clause in S:
        if complemento(un) in clause:
          clause.remove(complemento(un))

    else:
      y = False
      
  return I , S

lista = [["p"],["-p","q"],["-q","r","s"],["u","-s","r"],["r","t"],["p","s","-t"],["-r","u"]]
dic = {}

x, y = unit_propagate(dic, lista)

#print (x)
#print (y)

def literal_no_asignado(atomos, diccionario):
  for x in atomos:
    for y in x:
      if not y in diccionario:
        return y

def DPLL(S,I):
  Sp, Ip = unit_propagate(S,I)
  
  for i in Sp:
      if len(i) == 0:
          return "Insatisfacible", {}
  
  if len(Sp) == 0:
    return "Satisfacible", Ip

  p = literal_no_asignado(Sp, Ip)

  #SE BORRAN LAS CLAUSULAS COMPLETAS QUE TIENEN A L
  Spp = [x for x in Sp if p not in x]
  #SE BORRA Lc DE LAS DEMÁS CLAUSULAS
  for clause in Spp:
    if complemento(p) in clause:
      clause.remove(complemento(p))

  Ipp = Ip

  if len(p) == 1:
        Ipp[p] = 1
  else:
        Ipp[complemento(p)] = 0

  o, l = DPLL(Spp, Ipp)

  if o == "Satisfacible" and l == Ipp:
    return "Satisfacible", Ipp
  
  else:
    Sppp = Sp

    #SE BORRA Lc DE TODAS LAS CLAUSULAS
    Sppp = [x for x in Sp if complemento(p) not in x]

    #SE BORRA L DE LAS CLAUSULAS QUE TIENEN A L
    for clause in Sppp:
      if p in clause:
        clause.remove(p)

    Ippp = Ip

    if len(p) == 1:
          Ippp[p] = 0
    else:
          Ippp[complemento(p)] = 1

    return  DPLL(Sppp,Ippp)


lista1 = [["-p","q"],["q","r","s"],["-p","-q","r","s"],["r"],["q"]]
lista2 = [["p","-q","r"],["-p","-q","-r"],["-p","q","r"],["p","-q","-r"]]
lista3 = [["p","q"],["p","-q"],["-p","q"],["-p","-q"]]
dic = {}

x, y = DPLL(lista1, dic)

print(x)
print(y)

print('')

x, y = DPLL(lista2, dic)

print(x)
print(y)

print('')

x, y = DPLL(lista3, dic)

print(x)
print(y)

print('')
